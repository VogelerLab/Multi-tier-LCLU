#####################################################################################################################
# Title: LCLUC project map accuracy assessment script
# ---------------------------------------------------
# This script reads samples taken from classified map, reference labels, and points stratification information
# and performs map accuracy assessment based on Stehman method. This is a translation of code written in R with
# a minor modification to drop rows with class=0 assuming they are not valid points and assuming that predicted
# and reference labels are positive integer vectors of classes, ranging from 1 to maximum number of classes.
#
# Original code: CategoricalMapValidationFunctions_DifferentStrata.R
# Author:	PA Fekety
# Date:	2020.01.07
#
# Reference: Stephen V. Stehman (2014), "Estimating area and map accuracy for stratified random sampling when the
# strata are different from the map classes", International Journal of Remote Sensing, 35:13, 4923-4939,
# DOI: 10.1080/01431161.2014.930207
#
# Required input data:
#   - A .csv file containing validation data generated by BuildAndTestModel.py AND having a 'strata' column
#     added to it (this column should be generated by sampling the map used for validation point generation)
#   - Number of pixels associated with each stratum in the validation point generation map
# Generated output file(s):
#   - A .csv file containing assessed map accuracy components based on model validation results for the selected year
#
# Note: Variables in the variables setting block are set to the values used in the last program run and may not
#       represent the values used to create the files given in the SampleData folder.
####################################################################################################################
# Shahriar S. Heydari, Vogeler Lab, 4/24/2024

import sys
import numpy as np
import pandas as pd
from scipy import stats

# Variables setting block
##########################
# input maps are assumed to be of type Uint, with value of zero be invalid classes
mapNaNvalue = 0
pixelSize = 10                              # Sentinel-2 pixel size
pixelArea = pixelSize*pixelSize/10000       # pixel area is converted to hectares to keep numbers in float32 range
# points validation file created by 3.BuildandTestModel.py script WITH A COLUMN NAMED 'STRATA' ADDED TO IT. 
# The 'strata' column should contain reference labels for the original point when selected by stratified sampling 
# in the stratification map.
# It is assumed that the true labels are integers from 1 to maximum number of classes, and a zero in the .csv
# file means that the point is not available on that year for validation and accuracy assessment. It is also 
# assumed that for each year, the predicted and reference data for each point is stored in the input .csv
# file under 'Map_xxxx' and 'Ref_xxxx' columns.
points_validation_with_strata_file = r'.\SampleData\ValidationData\SA_finalModel_validation_w_strata.csv'
# number of pixels for each stratum in the original map used for stratification. 
nStratumSize = np.array([10381191,37310783,17118306,44765887,15237378,208964,1465665])*pixelArea
year = 2020                                 # evaluation year

################################################################################################################
# Helper functions
################################################################################################################


def categoricalMapValidation(strat, pred, ref, nStratumSize, ci=0.95):

    # Name:
    #	categoricalMapValidation2
    # Author:
    #	PA Fekety
    # Purpose:
    #	Calculate various validation statistics for validation of categorical maps based on a stratified random sample when the maps classes do NOT define the strata
    #	This is based off Stehman 2013
    # Parameters:
    #	strat (vector) - vector of the stratum call used to select refrence data
    #	pred (vector) - vector of the mapped predictions
    #	ref (vector) - vector of the reference data (true value from interpreted plots)
    #	nStratumSize (named vector) - number of pixels in each stratum for the map used to create the sample points
    #	ci (numeric) - confidence interval
    # Results:
    #	ans (list) - various validation statistics
    # Note:
    #	strata refers to the classes of the map used to generate the sample points
    #	map class refers to the classes of the final map

    # Create a data.frame to hold strat, ref, pred, and some indicator variables
    x = pd.DataFrame(data={'Stratum':strat, 'RefClass':ref, 'MapClass':pred})

    # Number of samples
    nSamples = len(x)

    # Strata used in selecting reference data
    strata = np.unique(x['Stratum'])
    nStrata = len(strata)

    # Final Map classes
    mapClasses = np.unique(x['MapClass'])
    nMapClasses = len(mapClasses)

    # Number of reference data in each stratum
    RefClasses, nRefSample = np.unique(x['Stratum'], return_counts=True)

    # Number of pixels in AOI
    nPopulation = np.sum(nStratumSize)

    # Check to see if all classes are in the strat, ref, pred
    if (np.unique(pred)-np.unique(ref)).any():
        print('Ref and Pred classes are not the same.')
        sys.exit(1)
    if (np.unique(strat)-np.unique(ref)).any():
        print('Ref and Strat classes are not the same.')
        sys.exit(1)

    # -------------------------
    # Error Matrix (Proportion)
    # Indicator function for cell proportions
    # y_u = 1 if pixel u is map class i and reference class j; 0 otherwise

    errorMatProportion_y_u = x
    for i in mapClasses:
        for j in mapClasses:
            errorMatProportion_y_u[str(i)+'_'+str(j)] = np.array((x['MapClass'] == i) & (x['RefClass'] == j))*1

    errorMatProportion = np.zeros((nMapClasses,nMapClasses))
    for i in mapClasses:
        for j in mapClasses:

            cellComponent = []
            for stratum in strata:
                thisComponent = np.mean(errorMatProportion_y_u[errorMatProportion_y_u['Stratum'] == stratum][str(i)+'_'+str(j)])
                cellComponent.append(thisComponent)
            thisProportion = np.sum(np.array(cellComponent) * nStratumSize) / nPopulation
            errorMatProportion[i - 1, j - 1] = thisProportion

            # -------------------------
    # User's Accuracy

    # Indicator function for User's Accuracy
    # y_u = 1 if pixel U is classified correctly and has map class k; 0 otherwise
    # x_u = 1 if pixel U is map class k; 0 otherwise
    # R = sum(y_u) / sum(x_u)

    userAcc_y_u = np.zeros((nSamples, nMapClasses))
    for mapClass in mapClasses:
        this_y_u = np.array((x['MapClass'] == x['RefClass']) & (x['MapClass'] == mapClass))*1
        userAcc_y_u[:, mapClass-1] = this_y_u

    userAcc_x_u = np.zeros((nSamples, nMapClasses))
    for mapClass in mapClasses:
        this_x_u = np.array((x['MapClass'] == mapClass))*1
        userAcc_x_u[:, mapClass-1] = this_x_u

    # Ratio
    ratioNumerator = []
    for mapClass in mapClasses:
        mean_y_u = []
        for stratum in strata:
            thisMean = np.mean(userAcc_y_u[x['Stratum'] == stratum][:,mapClass-1])
            mean_y_u.append(thisMean)
        ratioNumerator.append(np.sum(np.array(mean_y_u) * nStratumSize))

    ratioDenominator = []
    for mapClass in mapClasses:
        mean_x_u = []
        for stratum in strata:
            thisMean = np.mean(userAcc_x_u[x['Stratum'] == stratum][:,mapClass-1])
            mean_x_u.append(thisMean)
        ratioDenominator.append(np.sum(np.array(mean_x_u) * nStratumSize))

    usersAccuracy = np.array(ratioNumerator) / np.array(ratioDenominator)

    # Variance of User's Accuracy
    usersAccStratumVar = []
    for mapClass in mapClasses:
        usersAccStratumVar_y = []
        for stratum in strata:
            thisComponent = np.var(userAcc_y_u[x['Stratum'] == stratum][:, mapClass-1], ddof=1)
            usersAccStratumVar_y.append(thisComponent)
        usersAccStratumVar_x = []
        for stratum in strata:
            thisComponent = np.var(userAcc_x_u[x['Stratum'] == stratum][:, mapClass-1], ddof=1)
            usersAccStratumVar_x.append(thisComponent)

        usersAccStratumCov_xy = []
        for stratum in strata:
            thisComponent = np.cov(userAcc_x_u[x['Stratum'] == stratum][:, mapClass-1], userAcc_y_u[x['Stratum'] == stratum][:, mapClass-1], ddof=1)[0][1]
            usersAccStratumCov_xy.append(thisComponent)

        varComponents= []
        for stratum in strata:
            thisComponent = nStratumSize[stratum-1]**2 * (1 - nRefSample[stratum-1] / nStratumSize[stratum-1]) * \
                            (usersAccStratumVar_y[stratum-1] + usersAccuracy[mapClass-1]**2 * usersAccStratumVar_x[stratum-1]
                             - 2 * usersAccuracy[mapClass-1] * usersAccStratumCov_xy[stratum-1]) / nRefSample[stratum-1]
            varComponents.append(thisComponent)

        thisUsersAccStratumVar =  1 / ratioDenominator[mapClass-1]**2 * np.sum(varComponents)
        usersAccStratumVar.append(thisUsersAccStratumVar)

    usersAccStratumVar = np.array(usersAccStratumVar)
    negatives = np.where(usersAccStratumVar < 0)[0]
    if len(negatives) > 0:
        print('Negative element encountered in usersAccStratumVar:',usersAccStratumVar)
        usersAccStratumVar[negatives] = 0

    # Standard Deviation of User's accuracy
    usersAccuracyStdError = np.sqrt(usersAccStratumVar)

    # -------------------------
    # Producer's Accuracy

    # Indicator function for Producer's Accuracy
    # y_u = 1 if pixel u is correctly classified and has reference class k; 0 otherwise
    # x_u = if pixel u is in reference class k; 0 otherwise

    producerAcc_y_u = np.zeros((nSamples, nMapClasses))
    for mapClass in mapClasses:
        this_y_u = np.array((x['MapClass'] == x['RefClass']) & (x['MapClass'] == mapClass))*1
        producerAcc_y_u[:, mapClass-1] = this_y_u

    producerAcc_x_u = np.zeros((nSamples, nMapClasses))
    for mapClass in mapClasses:
        this_x_u = np.array((x['RefClass'] == mapClass))*1
        producerAcc_x_u[:, mapClass-1] = this_x_u

    # Ratio
    ratioNumerator = []
    for mapClass in mapClasses:
        mean_y_u = []
        for stratum in strata:
            thisMean = np.mean(producerAcc_y_u[x['Stratum'] == stratum][:,mapClass-1])
            mean_y_u.append(thisMean)
        ratioNumerator.append(np.sum(mean_y_u * nStratumSize))

    ratioDenominator = []
    for mapClass in mapClasses:
        mean_x_u = []
        for stratum in strata:
            thisMean = np.mean(producerAcc_x_u[x['Stratum'] == stratum][:,mapClass-1])
            mean_x_u.append(thisMean)
        ratioDenominator.append(np.sum(mean_x_u * nStratumSize))

    producersAccuracy = np.array(ratioNumerator) / np.array(ratioDenominator)

    # Variance of Producer's Accuracy
    producersAccStratumVar = []
    for mapClass in mapClasses:
        producersAccStratumVar_y = []
        for stratum in strata:
            thisComponent = np.var(producerAcc_y_u[x['Stratum'] == stratum][:, mapClass-1], ddof=1)
            producersAccStratumVar_y.append(thisComponent)

        producersAccStratumVar_x = []
        for stratum in strata:
            thisComponent = np.var(producerAcc_x_u[x['Stratum'] == stratum][:, mapClass-1], ddof=1)
            producersAccStratumVar_x.append(thisComponent)

        producersAccStratumCov_xy = []
        for stratum in strata:
            thisComponent = np.cov(producerAcc_x_u[x['Stratum'] == stratum][:, mapClass-1], producerAcc_y_u[x['Stratum'] == stratum][:, mapClass-1])[0][1]
            producersAccStratumCov_xy.append(thisComponent)


        varComponents = []
        for stratum in strata:
            thisComponent = nStratumSize[stratum-1]**2 * (producersAccStratumVar_y[stratum-1] + producersAccuracy[mapClass-1]**2
                                                          * producersAccStratumVar_x[stratum-1] - 2 * producersAccuracy[mapClass-1]
                                                          * producersAccStratumCov_xy[stratum-1]) / nRefSample[stratum-1]
            varComponents.append(thisComponent)
        thisProducersAccStratumVar = 1 / ratioDenominator[mapClass-1]**2 * np.sum(varComponents)
        producersAccStratumVar.append(thisProducersAccStratumVar)

    producersAccStratumVar = np.array(producersAccStratumVar)
    negatives = np.where(producersAccStratumVar < 0)[0]
    if len(negatives) > 0:
        print('Negative element encountered in producersAccStratumVar:',producersAccStratumVar)
        producersAccStratumVar[negatives] = 0
    # Standard Deviation of Producer's accuracy
    producersAccuracyStdError = np.sqrt(producersAccStratumVar)

    # -------------------------
    # Overall Accuracy

    # Indicator function for Overall Accuracy
    # y_u = 1 if pixel U is correctly classified; 2 if pixel U is not correctly classified

    for i in mapClasses:
        for j in mapClasses:
            errorMatProportion_y_u[str(i)+'_'+str(j)] = np.array((x['MapClass'] == i) & (x['RefClass'] == j))*1


    x['OverallAcc_y_u'] = np.array(x['MapClass'] == x['RefClass'])*1

    overallAccComponents = []
    for stratum in strata:
        thisComponent = nStratumSize[stratum-1] * np.mean(x[x['Stratum'] == stratum]['OverallAcc_y_u']) / nPopulation
        overallAccComponents.append(thisComponent)

    overallAccuracy = np.sum(overallAccComponents)

    # Variance of overall accuracy

    overallAccStratumVar = []
    for stratum in strata:
        thisComponent = np.var(x[x['Stratum'] == stratum]['OverallAcc_y_u'], ddof=1)
        overallAccStratumVar.append(thisComponent)

    varComponent = []
    for stratum in strata:
        thisComponent = nStratumSize[stratum-1]**2 * (1 - nRefSample[stratum-1] / nStratumSize[stratum-1]) *  \
                        overallAccStratumVar[stratum-1] / nRefSample[stratum-1]
        varComponent.append(thisComponent)
    varianceOverallAccuracy = (1 / nPopulation)**2 * np.sum(varComponent)

    # Standard Error of the overall Accuracy
    overallAccuracyStdError = np.sqrt(varianceOverallAccuracy)

    # -------------------------
    # Area Calculations
    # Indicator function for Proportion of Area
    # y_u = 1 if pixel u is in reference class k; 0 if pixel u is not in reference class k
    proportionArea_y_u = np.zeros((nSamples, nMapClasses))
    for mapClass in mapClasses:
        this_y_u = np.array(x['RefClass'] == mapClass)*1
        proportionArea_y_u[:, mapClass-1] = this_y_u

    proportionArea_y_u = np.hstack((np.array(x['Stratum'])[:,np.newaxis], proportionArea_y_u))

    means = np.zeros((nStrata, nMapClasses))
    for stratum in strata:
        thisMean = np.mean(proportionArea_y_u[proportionArea_y_u[:,0] == stratum], axis=0)
        means[stratum-1,: ] = thisMean[1:]

    proportionArea = []
    for mapClass in mapClasses:
        stratumPropArea = []
        for stratum in strata:
            thisComponent = nStratumSize[stratum-1] * means[stratum-1, mapClass-1] / nPopulation
            stratumPropArea.append(thisComponent)
        proportionArea.append(sum(stratumPropArea))
    proportionArea = np.array(proportionArea)

    adjustedArea = proportionArea * nPopulation * pixelArea

    # Variances of Area Proportions

    vars = np.zeros((nStrata, nMapClasses))
    for stratum in strata:
        thisVar = np.var(proportionArea_y_u[proportionArea_y_u[:,0] == stratum], axis=0, ddof=1)
        vars[stratum-1,: ] = thisVar[1:]

    areaProportionsVariance = []
    for mapClass in mapClasses:
        classVarTerm = []
        for stratum in strata:
            thisComponent = nStratumSize[stratum-1] **2 * (1 - nRefSample[stratum-1] / nStratumSize[stratum-1]) \
                            * vars[stratum-1, mapClass-1] / nRefSample[stratum-1]
            classVarTerm.append(thisComponent)
        areaProportionsVariance.append((1 / nPopulation)**2 * np.sum(classVarTerm))

    areaProportionsVariance = np.array(areaProportionsVariance)

    # Standard Error of Area Proportions
    areaProportionsStandardError = np.sqrt(areaProportionsVariance)
    adjAreaStandardError = areaProportionsStandardError * nPopulation * pixelArea

    # -------------------------
    # Test Statistics

    # Number of samples
    nSamples = len(pred)

    # alpha for CI
    alpha = 1 - ci

    # Test statistics
    nSamplePred = np.zeros(nMapClasses)
    for mapClass in mapClasses:
        nSamplePred[mapClass-1] =  len(np.where(pred == mapClass)[0])

    nSampleRef = np.zeros(nMapClasses)
    for mapClass in mapClasses:
        nSampleRef[mapClass-1] =  len(np.where(ref == mapClass)[0])

    tStatOverall = stats.t.isf(alpha/2, nSamples - 1) # For overall accuracy
    tStatRows = stats.t.isf(alpha/2, nSamplePred - 1) # For user's accuracy
    tStatColumns = stats.t.isf(alpha/2, nSampleRef - 1) # For producer's accuracy

    ans = {
        'CI': ci,
        'ErrorMatrixProportion': errorMatProportion,
        'OverallAccuracy': overallAccuracy,
        'OverallAccComponents': overallAccComponents,
        'OverallAccuracyHalfWidth': overallAccuracyStdError * tStatOverall,
        'UsersAccuracy': usersAccuracy,
        'UsersAccuracyHalfWidth': usersAccuracyStdError * tStatRows,
        'ProducersAccuracy': producersAccuracy,
        'ProducersAccuracyHalfWidth': producersAccuracyStdError * tStatColumns,
        'AdjustedArea': adjustedArea,
        'AreaHalfWidth': adjAreaStandardError * tStatColumns
    }

    return ans

##########################################################################################
# Main program
##########################################################################################

# reading points validation data
df = pd.read_csv(points_validation_with_strata_file)
# select columns for the validation year
pred = df['Map_'+str(year)].to_numpy()
ref = df['Ref_']+str(year).to_numpy()
strat = df['Strata'].to_numpy()
# drop null entries
null_index = np.where(ref == 0)[0]
pred = np.delete(pred, null_index)
ref = np.delete(ref, null_index)
strat = np.delete(strat, null_index)
classes = np.unique(strat)
# call the main assessment function
ans = categoricalMapValidation(strat, pred, ref, nStratumSize, ci=0.95)
# save the results into the output file in a .csv format
output_file = open(r'.\SampleData\ValidationData\map_assessment_results.csv', 'w')
output_file.write('Map OA, Map OA 95% CI\n')
output_file.write('{},{}\n'.format(ans['OverallAccuracy'],ans['OverallAccuracyHalfWidth']))
output_file.write('\nclass,{}\n'.format(','.join(str(x) for x in classes)))
output_file.write('Map OA components, {}\n'.format(','.join(str(x) for x in ans['OverallAccComponents'])))
output_file.write('\nclass, Map UA, Map UA 95% CI\n')
for i in range(len(ans['UsersAccuracy'])):
    output_file.write('{},{},{}\n'.format(classes[i],ans['UsersAccuracy'][i], ans['UsersAccuracyHalfWidth'][i]))
output_file.write('\nClass, {}\n'.format(','.join(str(x) for x in classes)))
output_file.write('Map PA, {}\n'.format(','.join(str(x) for x in ans['ProducersAccuracy'])))
output_file.write('Map PA 95% CI, {}\n'.format(','.join(str(x) for x in ans['ProducersAccuracyHalfWidth'])))
output_file.close()

